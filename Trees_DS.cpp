// ƒерево - свз€ный граф без циклов.
// Ѕинарное деверо - не более 2 узлов.
// ¬ысота дерева - количество узлов, расположенных на самом длинном пути от корн€ к листу.
// »ногда высоту определ€ют как ребра, а не узлы.
//  орень дерева - это узел у которого нет родительских узлов.
// Ћист - это узел у которого нет дочерних узлов.
// ќстальное - внутренние узлы ил просто узлы.
// ¬ дереве удобно хранить структуры, которые используют какую-то иерархию.
// ” бинарного дерева есть левый и правый дочерний узел.


/* –ассмотрим бинарное дерево, как и любое дерево, оно может быть определено рекурсивно.
  “о есть:
  1) ѕустое дерево.
  2) ”зел и два поддерева: T_left , T_right --- бинарные деревь€.
*/

//ќперации над бинарным деревом:
// +1) —оздание пустого.
// +2) —оздание бинарного дерева, содержащего один узел, по заданному элементу.
// +3) —оздание бинарного дерева по заданному корню и двум бинарным поддеревь€м этого корн€.
// +4) ”даление бинарного дерева.
// +5) ѕроверка на пустоту.
// -6) ќпределение или изменение данных, записанных в корне бинарного дерева.
// -7) ѕрисоединение к корню дерева правого или левого дочернего узла.
// +8) ѕрисоединениие к корню дерева левого или правого поддерева.
// +9) ќтсоединение от корн€ левого или правого поддерева.
// +10) —оздание полной копии дерева.
// +11) ѕолучение копии левого или правого поддерева корн€ бинарного дерева.

#include <iostream>
#include "btree.h"

int main()
{
  TTree tree = new TreeNode;
  TTree copy = nullptr;
  init(tree, 1);
  init(tree->left, 2);
  init(tree->right, 3);
  init(tree->left->left, 4);

  viewTree(tree);
  copyTree(tree, copy);
  viewTree(copy);
  destroyTree(tree);
  std::cout << tree;
}


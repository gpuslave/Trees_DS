// Дерево - свзяный граф без циклов.
// Бинарное деверо - не более 2 узлов.
// Высота дерева - количество узлов, расположенных на самом длинном пути от корня к листу.
// Иногда высоту определяют как ребра, а не узлы.
// Корень дерева - это узел у которого нет родительских узлов.
// Лист - это узел у которого нет дочерних узлов.
// Остальное - внутренние узлы ил просто узлы.
// В дереве удобно хранить структуры, которые используют какую-то иерархию.
// У бинарного дерева есть левый и правый дочерний узел.


/* Рассмотрим бинарное дерево, как и любое дерево, оно может быть определено рекурсивно.
  То есть:
  1) Пустое дерево.
  2) Узел и два поддерева: T_left , T_right --- бинарные деревья.
*/

//Операции над бинарным деревом:
// +1) Создание пустого.
// +2) Создание бинарного дерева, содержащего один узел, по заданному элементу.
// +3) Создание бинарного дерева по заданному корню и двум бинарным поддеревьям этого корня.
// +4) Удаление бинарного дерева.
// +5) Проверка на пустоту.
// -6) Определение или изменение данных, записанных в корне бинарного дерева.
// -7) Присоединение к корню дерева правого или левого дочернего узла.
// +8) Присоединениие к корню дерева левого или правого поддерева.
// +9) Отсоединение от корня левого или правого поддерева.
// +10) Создание полной копии дерева.
// +11) Получение копии левого или правого поддерева корня бинарного дерева.

// Дерево формула:
// ((a+b)*(c-d))*f
//
//       *
//      / \
//     *   f
//    / \
//   +   -
//  /\   /\
// a  b c  d
//

// Существует два вида обхода - в глубину(с лева на право), в ширину(по уровеням).
// 
// Существует три варианта обхода в глубину - префиксный, постфиксный, инфиксный.
//   A
//  / \
// B   C
// 
//  1) ABC - префикс(прямой)
//  2) BAC - инфикс(симметричный)
//  3) BCA - постфикс(обратный)
// 
// 
// Обход в ширину с помощью очереди.


// Идеально сбалансированное дерево - это такое дерево, что для каждого узла число узлов в левом и правом поддеревьях
// отличается не более чем на единицу.
// Общий алгоритм посторения - исползовать первый узел в качестве корня, затем постоить левое сбалансированное поддерево
// с числом узлов n_l = n div 2 , и построить правое сбалансированное подддерево с числом узлов n_r = n - n_l - 1.
// Исходные данные в файле записаны - сначала количество узлов, а затем последовательно все узлы дерева.

/* Бинарное дерево поиска - бинарное дерево, все элементы которого удовлетворяют условию, значение узла меньше, 
   чем значение в узлах его правого поддерева и больш, чем во всех узлах левого поддерева: 
   (обход инфиксным спуком в глубину)

//       *
//      / \
//     *   f
//    / \
//   +   -
//  /\   /\
// a  b c  d
  
  Операции:
  1) Создание пустого дерева
  2) Очистка/удаление
  3) Проверка на пустоту

  4) Вставка элемента (элемента всегда вставляется в лист)
  5) Удаление элемента ( при удалении возможно три случая: элемент - лист(просто удаляется), 
                                                           элемент - имеет одного потомка(левого или правого, то этот потомок вместе со своими поддеревьями
                                                           становиться на место удаляемого элемента, а для удаляемого совершается процедура удаления),
                                                           элемент - имеет обоих потомков(ищется его ближайший преемник(узел с наименьшим ключом, принадлежащий правому поддереву удаляемого узла, этот узел либо совсем не имеет потомков, либо имеет только правого потомка, так как в противном случае он не был бы наименьшим, наименьший принадлежал бы его левому поддереву) или ближайший предшественник)
                       )
  6) Поиск элемента по ключу


*/



/* 11/9/23  
trie-trees(префиксное дерево, луч, бор):
    используется для хранение элементов по ключу, где ключем является слово.

    Представление узла дерева:
    1) В узле хранится массив, где каждый элемент массива соответсвует каждой букве алфавита
    2) Односвзяные списки

    Обход такого дерева соответствует инфиксному обходу обычного дереваю.
*/





#include <iostream>
#include "btree.h"

int main()
{
  TTree tree = new TreeNode;
  TTree copy = nullptr;
  init(tree, 1);
  init(tree->left, 2);
  init(tree->right, 3);
  init(tree->left->left, 4);

  viewTree(tree);
  copyTree(tree, copy);
  viewTree(copy);
  destroyTree(tree);
  std::cout << tree;
}

